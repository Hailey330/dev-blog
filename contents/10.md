---
date: '2022-07-14'
title: 'Merge vs Rebase vs Cherry-Pick'
categories: ['Git']
summary: '프로그래밍 세계에서의 First Class Citizen'
thumbnail: './09.png'
---

# Merge 🗞

### 먼저, 기능 구현을 할 때 순서를 정리해보면?

1. 기능 구현을 위해서 해당 기능을 구현하기 위한 브랜치를 생성한다.
2. 기능 구현이 되는 경우 해당 기능을 main 브랜치에 merge 한다.

이처럼 기능을 모두 완성하게 되면 사용하고 있는 main 브랜치에 본인이 작성한 기능 commit을 모두 합쳐줘야 한다.

두 브랜치를 합치는 과정을 git에서는 merge 라는 기능으로 도와준다.

먼저, 이 과정을 직접 눈으로 확인하면서 체크해볼 수 있는 Git GUI, 소스트리(SourceTree)라는 프로그램을 설치해보았다.

- [소스트리 링크](https://www.sourcetreeapp.com/)로 들어가서 'Download for Mac OS X' 버튼을 클릭해서 다운로드!

### 기능 브랜치에서 기능 구현을 완료했다 생각하고, 기능 브랜치를 main에 merge 하는 작업

![image](https://user-images.githubusercontent.com/57790541/179148143-1eb1fbe2-a5be-4c10-af71-26fdec5022bd.png)

```bash
$ git checkout main
$ git merge feat/md
```

![image](https://user-images.githubusercontent.com/57790541/179148826-90178abb-9c13-40fc-93b0-99fc36978806.png)

![image](https://user-images.githubusercontent.com/57790541/179148966-c6f50d7c-695a-43eb-ab9a-c6b93891c2f4.png)

동작 결과를 보면 `Fast-forward`가 동작 되어있다라는 것을 볼 수 있다.

깃 그래프 상에서도 제일 아래 commit인 Update commit을 가리키고 있던 main 브랜치가 기능 브랜치가 가리키고 있던 commit으로 올라왔다.

말 그대로 가리키고 있던 commit을 merge할 브랜치의 commit으로 이동하는 것이 merge의 방법 중 하나인 `Fast-forward`이다.

보통 현재 브랜치가 merge할 브랜치로 최신 정보들을 모두 따라가는 두 브랜치의 베이스가 같을 때 `Fast-forward`를 기본적으로 제공한다.

즉, A브랜치에 B브랜치를 merge할 때 B브랜치가 온전히 A브랜치 이후의 commit들을 가리키고 있으면 A브랜치를 B브랜치로 이동하기만 한다.

- 3-way-merge

지금까지는 특별한 분기점 없이 merge하는 과정을 나타냈다면, 조금 다른 상황을 이야기를 해보자.

기존 main 브랜치에 변경사항이 생긴 것을 기능 브랜치에 반영을 해야한다면?

![image](https://user-images.githubusercontent.com/57790541/179153121-bb27dc19-95b7-4ee5-87e9-e06b77f2bdfb.png)

main 브랜치를 분기한 develop 브랜치에서 변경 작업이 생긴 것을 볼 수 있다.
빨간색의 다른 브랜치 뿌리가 진행되어서 올라가고 있는 모습!

작업 중인 로컬 기능 브랜치에 Feat: 다른 내용 추가 커밋을 합쳐야 한다.
`Fast-forward`의 조건인 두 브랜치의 베이스가 같은 것이 아니라, 두 브랜치의 베이스가 지금 다르기 때문에 결과가 다를 것으로 예상된다.

일단 main2에서 merge를 진행해 보도록 하자.

```bash
$ git fetch origin develop
$ git merge origin/develop
```

![image](https://user-images.githubusercontent.com/57790541/179154448-15fba101-fa93-4a41-ac1b-2a8a82e37b40.png)

![image](https://user-images.githubusercontent.com/57790541/179155756-421728c8-57ed-44ae-8e02-8c36e9e68c14.png)

새로운 merge commit인 `Merge remote-tracking branch`라는 commit이 생성되면서 합쳐지는 것을 볼 수 있다.

main2인 feature 브랜치가 해당 commit을 가리키도록 변경이 된다.

즉, git이 별도의 최적 공통 조상을 자동으로 찾는 auto-merge로 commit을 하나 생성한 후 해당 commit을 가리키도록 이동하는 것이다.

그럼 이제 변경된 develop 요구사항을 반영한 채 다른 기능 구현을 진행할 수 있게 된다.

- conflict

이전처럼 작성을 쭉 해오다가, 내용을 추가하거나 수정을 진행하고 commit을 했다면?

기능 브랜치와 main2 브랜치의 동일한 파일을 지금 수정하려 하는 상황이기 때문에 똑같은 수정 파일이 있어 충돌이 발생한다.

일단 반영을 진행해야 하니까 똑같이 merge를 진행해보자.

![image](https://user-images.githubusercontent.com/57790541/179163013-3c0d50e3-2fe9-4f81-9e59-5c530cfb0f50.png)

메시지들을 보면 auto-merge를 시도했지만, README.md 에서 conflict이 발생해서 실패했다고 나온다.

저 상황에서 `git status`를 치면 더 자세한 이력을 보여준다.

![image](https://user-images.githubusercontent.com/57790541/179162487-74c75243-dc85-4d93-98c2-c797c01b60db.png)

unmerge 되어있는 commit 이력이 있으니 이를 해결해야 하며, 해당 path는 README.md 에서 발생했다고 보여준다.

![image](https://user-images.githubusercontent.com/57790541/179162752-021a1e97-2c0c-47c5-ad0c-58cfc55e252d.png)

깃 그래프 내에서도 merge 되어 있지 않은 uncommited changes라는 회색 commit이 하나 생성되어 있음을 확인할 수 있다.

해당 코드로 넘어가서 어떻게 코드가 되어있는지 먼저 확인을 해보자.

![image](https://user-images.githubusercontent.com/57790541/179162130-355d2757-49fc-42c0-b31e-6f4539d0efa6.png)

conflict이 발생한 부분에 대해서 두 브랜치에서 작성한 코드 두 개를 전부 포함하고 있다.

위에 있는 HEAD 브랜치가 현재 브랜치고, 아래에 origin/develop 브랜치가 merge할 브랜치다.

이 때 merge를 계속 진행하기 위해서는 해당 부분을 직접 수정하거나 IDE에서 제공하는 자동 수정을 진행하면 된다.

![image](https://user-images.githubusercontent.com/57790541/179164512-3df5a91a-142c-4a6d-9b33-9978b3d16c4b.png)

수정 후 `git add`를 통해서 해당 파일을 스테이징 해두면 기다리고 있던 이 회색 merge commit에 포함이 된다.

이후에 `git commit`을 하면 merge commit이 정상적으로 생성됨을 확인할 수 있다.

마지막으로는 처음에 이야기했던 `Fast-forward` 라는 명령어에는 옵션을 제거하지 않으면 항상 fast-forward 동작을 기본적으로 제공한다.

다만, 깃허브에서 제공하는 pull request는 조금 다르게 동작하는 세 가지 merge 방법을 따로 제공한다.

이 세가지 방법에 대해서 알아보자!

![image](https://user-images.githubusercontent.com/57790541/179165466-0231472e-3b72-4c0e-8f54-401d379c8ef7.png)

### Create merge commit

```bash
$ git checkout main
$ git merge --no-ff feature
```

베이스 브랜치가 같더라도 fast-forward를 진행하는 것이 아니라 하나의 merge commit을 생성해서 merge를 진행하는 방법이다.
이렇게 진행하게 될 경우, 기능 구현을 할 때 사용했던 commit들이 하나하나 살아있어 이를 사용할 여지를 남김과 동시에 만든 기능에 대해서 merge 분기점이 생김으로 어떤 기능을 만들어 main에 merge했는지 가독성이 좋아진다.

### Squash and merge

```bash
$ git checkout main
$ git merge --squash feature
$ git commit -m "squash merge message"
```

create merge commit과 같이 하나의 merge commit을 생성해서 해당 commit을 바라보게 하는데
feature에서 작업했던 모든 commi을 하나의 commit으로 통합해서 merge하는 작업이다.

이렇게 될 경우 여러 개의 기능 구현이 있을 때 알아보기 힘든 점이 있고, 특정 기능에 대한 commit을 하나만 두어서 이전보다는 어떤 기능을 작업했는지 가독성이 더 좋아지는 장점이 있다.

![image](https://user-images.githubusercontent.com/57790541/179167545-4ebcf60b-b287-48cb-823f-886270ff59d9.png)

실제로 작성한 commit과 merge된 commit의 내용이 다른 것을 확인할 수 있다.

이처럼 Pull Request 각각에 대한 commit을 하나를 남기고 어떤 기능을 완료했는지 한 눈에 알 수 있기 때문에 가독성이 높아진 모습이다.

### Rebase and merge

# Rebase

- Rebase란?

# Cherry-pick

- Cherry-pick이란?
- Cherry-pick 사용하기
- conflict

<br/>

# ✨ 정리

### 참고 내용

[test](https://developer.mozilla.org/ko/docs/Glossary/First-class_Function)
